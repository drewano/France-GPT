"""
Gestionnaire de cycle de vie pour l'application FastAPI.

Ce module contient la fonction de cycle de vie qui g√®re l'initialisation
et la finalisation de l'application FastAPI avec l'agent IA.
"""

import asyncio
import logging
from contextlib import asynccontextmanager
from fastapi import FastAPI
import httpx  # Import httpx

# Imports locaux
from .config import settings
from ..db.session import initialize_database
from .s3_client import ensure_bucket_exists

# Configuration du logging
logger = logging.getLogger("datainclusion.agent")


def setup_environment():
    """
    Configure l'environnement d'ex√©cution de l'application.

    Cette fonction :
    - Affiche les avertissements de configuration
    - Valide les param√®tres critiques
    """
    logger.info("üîß Configuration de l'environnement...")
    # Avertissements pour la configuration
    if settings.agent.SECRET_KEY == "your-secret-key-here-change-in-production":
        logger.warning(
            "‚ö†Ô∏è SECRET_KEY utilise la valeur par d√©faut - √† changer en production !"
        )

    if settings.agent.CORS_ORIGINS == ["*"]:
        logger.warning(
            "‚ö†Ô∏è CORS_ORIGINS autorise tous les domaines - √† restreindre en production !"
        )

    if not settings.agent.OPENAI_API_KEY:
        logger.warning(
            "‚ö†Ô∏è OPENAI_API_KEY non d√©finie - certaines fonctionnalit√©s peuvent ne pas fonctionner"
        )

    logger.info("‚úÖ Configuration de l'environnement termin√©e")


@asynccontextmanager
async def lifespan(_app: FastAPI):
    """
    Gestionnaire de cycle de vie pour l'application combin√©e.

    G√®re la connexion aux serveurs MCP et l'initialisation de la base de donn√©es
    avec une logique de retry et backoff exponentiel.

    Args:
        _app: Instance FastAPI (renamed to _app as it's not directly used)
    """
    logger.info("üöÄ D√©marrage de l'application Chainlit + FastAPI...")

    # Configuration de l'environnement
    setup_environment()

    # Initialisation de la base de donn√©es
    try:
        await initialize_database()
        logger.info("‚úÖ Base de donn√©es initialis√©e avec succ√®s")
    except Exception as e:
        logger.critical("‚ùå √âchec de l'initialisation de la base de donn√©es: %s", e)
        raise RuntimeError(
            f"L'application ne peut pas d√©marrer sans base de donn√©es: {e}"
        ) from e

    # V√©rification et cr√©ation du bucket S3 si n√©cessaire
    try:
        if settings.agent.DEV_AWS_ENDPOINT:
            bucket_exists = await ensure_bucket_exists()
            if bucket_exists:
                logger.info("‚úÖ Bucket S3 v√©rifi√©/cr√©√© avec succ√®s")
            else:
                logger.warning("‚ö†Ô∏è Impossible de v√©rifier/cr√©er le bucket S3")
        else:
            logger.info(
                "‚ÑπÔ∏è  Pas de configuration S3 d√©tect√©e, passage de la v√©rification du bucket"
            )
    except Exception as e:
        logger.critical("‚ùå √âchec de la configuration du bucket S3: %s", e)
        raise RuntimeError(
            f"L'application ne peut pas d√©marrer sans bucket S3: {e}"
        ) from e

    # Logique de connexion aux serveurs MCP avec retry et backoff exponentiel
    max_retries = settings.agent.AGENT_MCP_CONNECTION_MAX_RETRIES
    base_delay = settings.agent.AGENT_MCP_CONNECTION_BASE_DELAY
    backoff_multiplier = settings.agent.AGENT_MCP_CONNECTION_BACKOFF_MULTIPLIER

    all_services_healthy = False
    for attempt in range(max_retries):
        try:
            logger.info("ü©∫ V√©rification de la sant√© des serveurs MCP...")
            all_services_healthy = True
            service_configs = settings.mcp_services
            if not service_configs:
                logger.warning(
                    "Aucun service MCP n'est configur√©. D√©marrage sans v√©rification."
                )
                break

            async with httpx.AsyncClient() as client:
                for service_config in service_configs:
                    health_check_url = f"http://mcp_server:{service_config.port}/health"
                    logger.info(
                        "   - Test de '%s' sur le port %s...",
                        service_config.name,
                        service_config.port,
                    )
                    response = await client.get(health_check_url)
                    response.raise_for_status()
                    logger.info("   ‚úì Le service '%s' est sain.", service_config.name)

            # Si toutes les v√©rifications ont r√©ussi, on sort de la boucle
            break

        except (httpx.RequestError, httpx.HTTPStatusError) as e:
            all_services_healthy = False
            error_details = (
                f"({e.response.status_code} - {e.response.text})"
                if isinstance(e, httpx.HTTPStatusError)
                else str(e)
            )
            logger.warning("‚ùå Un service MCP n'est pas encore pr√™t: %s", error_details)
            if attempt == max_retries - 1:
                raise RuntimeError(
                    f"√âchec de la connexion aux serveurs MCP apr√®s {max_retries} tentatives."
                ) from e
            delay = base_delay * (backoff_multiplier**attempt)
            logger.warning(
                "Tentative %d/%d √©chou√©e. Nouvelle tentative dans %.2fs...",
                attempt + 1,
                max_retries,
                delay,
            )
            await asyncio.sleep(delay)

    if all_services_healthy:
        logger.info("‚úÖ Tous les serveurs MCP sont sains et joignables.")
        # L'application est pr√™te
        yield
        # Le code apr√®s yield s'ex√©cute lors du shutdown
        logger.info("üõë Arr√™t de l'application...")
        logger.info("‚úÖ Nettoyage termin√©")
    else:
        # Si on arrive ici, c'est que la boucle s'est termin√©e sans succ√®s
        logger.critical(
            "‚ùå Impossible de d√©marrer : tous les services MCP ne sont pas disponibles."
        )
